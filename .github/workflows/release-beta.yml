name: Release Beta

on:
  workflow_dispatch:
    inputs:
      tag:
        description: Tag (e.g., v1.0.4-beta) to release when running manually
        required: true
        type: string
      source_ref:
        description: Source branch or tag to tag from
        type: string
        default: main
      create_tag:
        description: Create or update the tag before building (true/false)
        type: string
        default: "true"
      features:
        description: New features and improvements (one per line)
        type: string
        default: ""
      fixes:
        description: Bug fixes (one per line)
        type: string
        default: ""
      changes:
        description: Other changes and improvements (one per line)
        type: string
        default: ""
      known_issues:
        description: Known issues (one per line)
        type: string
        default: ""
      next_steps:
        description: Roadmap notes (one per line)
        type: string
        default: ""

permissions:
  contents: write
  id-token: write

jobs:
  prepare:
    name: Ensure tag
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.tag.outputs.tag }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Configure git
        run: |
          git config user.name "${{ github.actor }}"
          git config user.email "${{ github.actor }}@users.noreply.github.com"
      - name: Create or verify tag
        id: tag
        env:
          TAG_NAME: ${{ inputs.tag }}
          SOURCE_REF: ${{ inputs.source_ref }}
          CREATE_TAG: ${{ inputs.create_tag }}
        run: |
          set -euo pipefail
          if [ -z "$TAG_NAME" ]; then
            echo "Tag input is required." >&2
            exit 1
          fi
          git fetch origin --prune --tags
          if ! git ls-remote --exit-code --heads origin "$SOURCE_REF" >/dev/null; then
            echo "Source ref '$SOURCE_REF' not found on origin." >&2
            exit 1
          fi
          if git ls-remote --exit-code --tags origin "refs/tags/$TAG_NAME" >/dev/null; then
            echo "Tag '$TAG_NAME' already exists on origin." >&2
            if [ "${CREATE_TAG,,}" != "true" ]; then
              echo "create_tag is not true; leaving tag untouched." >&2
            else
              git fetch origin "$SOURCE_REF"
              git checkout --detach "origin/$SOURCE_REF"
              git tag -f "$TAG_NAME"
              git push origin "refs/tags/$TAG_NAME" --force
            fi
          else
            git fetch origin "$SOURCE_REF"
            git checkout --detach "origin/$SOURCE_REF"
            git tag "$TAG_NAME"
            git push origin "refs/tags/$TAG_NAME"
          fi
          echo "tag=$TAG_NAME" >> "$GITHUB_OUTPUT"

  build-windows:
    needs: prepare
    uses: ./.github/workflows/windows-testing-build.yml
    with:
      ref: ${{ needs.prepare.outputs.tag }}
    secrets: inherit

  build-linux:
    needs: prepare
    uses: ./.github/workflows/linux-testing-build.yml
    with:
      ref: ${{ needs.prepare.outputs.tag }}
    secrets: inherit

  release:
    name: Publish beta release
    runs-on: ubuntu-latest
    environment:
      name: beta-release
    needs:
      - prepare
      - build-windows
      - build-linux
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare.outputs.tag }}
          fetch-depth: 0
      - name: Download Windows artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build-windows.outputs.artifact_name }}
          path: artifacts/windows
      - name: Download Linux artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build-linux.outputs.artifact_name }}
          path: artifacts/linux
      - name: Inspect downloaded artifacts
        run: |
          set -euo pipefail
          echo "Contents of artifacts directory:"
          find artifacts -maxdepth 4 -print
      - name: Extract archived artifacts (if any)
        run: |
          set -euo pipefail
          shopt -s nullglob
          for dir in artifacts/windows artifacts/linux; do
            if [ -d "$dir" ]; then
              for archive in "${dir}"/*.zip "${dir}"/*.tar "${dir}"/*.tar.gz "${dir}"/*.tgz; do
                [ -e "$archive" ] || continue
                echo "Extracting $archive"
                case "$archive" in
                  *.tar.gz|*.tgz) tar -xzf "$archive" -C "$dir" ;;
                  *.tar) tar -xf "$archive" -C "$dir" ;;
                  *.zip) unzip -q "$archive" -d "$dir" ;;
                esac
                rm "$archive"
              done
            fi
          done
      - name: Prepare release notes
        env:
          VERSION: ${{ needs.prepare.outputs.tag }}
          WINDOWS_HASH: ${{ needs.build-windows.outputs.hash }}
          WINDOWS_VT_URL: ${{ needs.build-windows.outputs.vt_url }}
          LINUX_HASH: ${{ needs.build-linux.outputs.hash }}
          LINUX_VT_URL: ${{ needs.build-linux.outputs.vt_url }}
          REPO: ${{ github.repository }}
          FEATURES: ${{ inputs.features }}
          FIXES: ${{ inputs.fixes }}
          CHANGES: ${{ inputs.changes }}
          KNOWN_ISSUES: ${{ inputs.known_issues }}
          NEXT_STEPS: ${{ inputs.next_steps }}
        run: |
          python <<'PY'
          from pathlib import Path
          import os
          
          repo = os.environ["REPO"]
          version = os.environ["VERSION"]
          template_path = Path("Release Notes") / "template.md"
          if not template_path.exists():
              raise SystemExit(f"Template not found: {template_path}")
          text = template_path.read_text(encoding="utf-8")
          
          def format_lines(value, default="- None"):
              import re
              normalized = value.replace(' - **', '\n- **')
              normalized = re.sub(r' {2,}-', lambda m: '\n' + ' ' * (len(m.group(0)) - 1) + '-', normalized)
              formatted = []
              for raw_line in normalized.splitlines():
                  if not raw_line.strip():
                      continue
                  stripped = raw_line.lstrip()
                  if stripped.startswith(('-', '*', '+')):
                      formatted.append(raw_line.rstrip())
                  else:
                      formatted.append(f"- {stripped}")
              if not formatted:
                  return default
              return "\n".join(formatted)
          
          windows_vt = os.environ.get("WINDOWS_VT_URL", "").strip() or "https://www.virustotal.com/"
          linux_vt = os.environ.get("LINUX_VT_URL", "").strip() or "https://www.virustotal.com/"
          windows_hash = os.environ.get("WINDOWS_HASH", "").strip() or "None"
          linux_hash = os.environ.get("LINUX_HASH", "").strip() or "None"
          asset_windows = "PatchOpsIII.exe"
          asset_linux = "PatchOpsIII.AppImage"
          base_url = f"https://github.com/{repo}/releases/download/{version}"
          windows_download = f"{base_url}/{asset_windows}"
          linux_download = f"{base_url}/{asset_linux}"
          
          replacements = {
              "VERSION": version,
              "WINDOWS_VT_URL": windows_vt,
              "LINUX_VT_URL": linux_vt,
              "FEATURES_LIST": format_lines(os.environ.get("FEATURES", "")),
              "CHANGES_LIST": format_lines(os.environ.get("CHANGES", "")),
              "FIXES_LIST": format_lines(os.environ.get("FIXES", "")),
              "KNOWN_ISSUES_LIST": format_lines(os.environ.get("KNOWN_ISSUES", "")),
              "NEXT_STEPS_LIST": format_lines(os.environ.get("NEXT_STEPS", "")),
              "WINDOWS_DOWNLOAD_URL": windows_download,
              "LINUX_DOWNLOAD_URL": linux_download,
              "WINDOWS_SHA256": windows_hash,
              "LINUX_SHA256": linux_hash,
          }
          for key, value in replacements.items():
              text = text.replace(f"{{{{{key}}}}}", value)
          
          Path("release-notes.md").write_text(text + "\n", encoding="utf-8")
          PY
      - name: Organize release assets
        env:
          VERSION: ${{ needs.prepare.outputs.tag }}
        run: |
          set -euo pipefail
          mkdir -p release
          echo "Collecting release binaries"
          win_exec=$(find artifacts/windows -type f -name 'PatchOpsIII.exe' -print -quit)
          if [ -z "$win_exec" ]; then
            echo "Windows executable not found under artifacts/windows" >&2
            find artifacts/windows -type f -print >&2
            exit 1
          fi
          cp "$win_exec" "release/PatchOpsIII.exe"
          if [ -f "$(dirname "$win_exec")/PatchOpsIII.sig" ]; then
            cp "$(dirname "$win_exec")/PatchOpsIII.sig" "release/PatchOpsIII.sig"
          fi
          linux_exec=$(find artifacts/linux -type f -name 'PatchOpsIII.AppImage' -print -quit)
          if [ -z "$linux_exec" ]; then
            echo "Linux binary not found under artifacts/linux" >&2
            find artifacts/linux -type f -print >&2
            exit 1
          fi
          cp "$linux_exec" "release/PatchOpsIII.AppImage"
          chmod +x "release/PatchOpsIII.AppImage"
          if [ -f "$(dirname "$linux_exec")/PatchOpsIII.AppImage.sig" ]; then
            cp "$(dirname "$linux_exec")/PatchOpsIII.AppImage.sig" "release/PatchOpsIII.AppImage.sig"
          fi
      - name: Publish GitHub release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.prepare.outputs.tag }}
          name: PatchOpsIII ${{ needs.prepare.outputs.tag }}
          prerelease: true
          body_path: release-notes.md
          files: |
            release/*
        env:
          GITHUB_TOKEN: ${{ secrets.RELEASE_PAT }}
