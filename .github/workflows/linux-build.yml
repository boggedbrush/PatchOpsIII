name: Linux Build

on:
  push:
    branches:
      - Testing
      - testing
  pull_request:
    branches:
      - Testing
      - testing
  workflow_dispatch:
  workflow_call:
    inputs:
      ref:
        description: Git ref to build
        required: false
        type: string
        default: ''
    outputs:
      hash:
        description: SHA256 hash of the AppImage
        value: ${{ jobs.build-linux.outputs.hash }}
      vt_url:
        description: VirusTotal URL for the AppImage
        value: ${{ jobs.build-linux.outputs.vt_url }}
      artifact_name:
        description: Name of the produced artifact
        value: ${{ jobs.build-linux.outputs.artifact_name }}

permissions:
  contents: read
  id-token: write

jobs:
  build-linux:
    name: Build Linux AppImage
    runs-on: ubuntu-latest
    outputs:
      hash: ${{ steps.compute_hash.outputs.hash }}
      vt_url: ${{ steps.compute_hash.outputs.vt_url }}
      artifact_name: PatchOpsIII-linux
    defaults:
      run:
        shell: bash
        working-directory: .
    env:
      LINUX_DIST_DIR: dist/linux
      LINUX_APPIMAGE: PatchOpsIII.AppImage
      VT_CLI_ARCHIVE: vt-cli.zip
      COSIGN_PRIVATE_KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}
      COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
      VT_API_KEY: ${{ secrets.VT_API_KEY }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref != '' && inputs.ref || github.ref }}
      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y appstream desktop-file-utils file libfuse2 patchelf
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: requirements.txt
      - name: Install build dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install pillow
      - name: Download AppImage tooling
        run: |
          set -euo pipefail
          mkdir -p tools
          cd tools
          curl -fL --retry 3 -o appimagetool-x86_64.AppImage \
            https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage
          chmod +x appimagetool-x86_64.AppImage
          ln -sf appimagetool-x86_64.AppImage appimagetool
      - name: Extract Python runtime AppDir
        run: |
          set -euo pipefail
          APPDIR="$PWD/AppDir"
          RUNTIME_APPIMAGE="python3.11.14-cp311-cp311-manylinux2014_x86_64.AppImage"
          RUNTIME_URL="https://github.com/niess/python-appimage/releases/download/python3.11/$RUNTIME_APPIMAGE"
          RUNTIME_DIR="$PWD/tools/python-runtime"
          rm -rf "$APPDIR" "$RUNTIME_DIR"
          mkdir -p "$RUNTIME_DIR"
          curl -fL --retry 3 -o "$RUNTIME_DIR/$RUNTIME_APPIMAGE" "$RUNTIME_URL"
          chmod +x "$RUNTIME_DIR/$RUNTIME_APPIMAGE"
          (cd "$RUNTIME_DIR" && "./$RUNTIME_APPIMAGE" --appimage-extract)
          mv "$RUNTIME_DIR/squashfs-root" "$APPDIR"
          rm -f "$APPDIR"/python*.desktop "$APPDIR"/python*.png
          rm -f "$APPDIR"/usr/share/applications/python*.desktop
          find "$APPDIR/usr/share/icons" -type f -name 'python*.png' -delete
      - name: Generate AppImage icon
        run: |
          python <<'PY'
          from pathlib import Path
          from PIL import Image

          ico_path = Path('PatchOpsIII.ico')
          png_path = Path('PatchOpsIII.png')
          image = Image.open(ico_path)
          frame_index = 0
          if getattr(image, 'n_frames', 1) > 1:
              candidates = []
              for idx in range(image.n_frames):
                  image.seek(idx)
                  candidates.append((idx, image.size[0] * image.size[1]))
              frame_index = max(candidates, key=lambda item: item[1])[0]
              image.seek(frame_index)
          image.convert('RGBA').save(png_path, format='PNG')
          PY
      - name: Assemble AppDir contents
        run: |
          set -euo pipefail
          APPDIR="$PWD/AppDir"
          mkdir -p "$APPDIR/usr/bin" "$APPDIR/usr/share/patchopsiii" "$APPDIR/usr/share/applications" "$APPDIR/usr/share/icons/hicolor/256x256/apps" "$LINUX_DIST_DIR"
          install -Dm755 packaging/linux/AppRun "$APPDIR/AppRun"
          install -Dm755 packaging/linux/PatchOpsIII.sh "$APPDIR/usr/bin/PatchOpsIII"
          install -Dm644 packaging/linux/PatchOpsIII.desktop "$APPDIR/PatchOpsIII.desktop"
          install -Dm644 packaging/linux/PatchOpsIII.desktop "$APPDIR/usr/share/applications/PatchOpsIII.desktop"
          install -Dm644 PatchOpsIII.png "$APPDIR/PatchOpsIII.png"
          install -Dm644 PatchOpsIII.png "$APPDIR/usr/share/icons/hicolor/256x256/apps/PatchOpsIII.png"
          install -Dm644 PatchOpsIII.png "$APPDIR/.DirIcon"
          install -Dm644 PatchOpsIII.ico "$APPDIR/usr/share/patchopsiii/PatchOpsIII.ico"
          install -Dm644 presets.json "$APPDIR/usr/share/patchopsiii/presets.json"
          install -Dm644 config.py "$APPDIR/usr/share/patchopsiii/config.py"
          install -Dm644 dxvk_manager.py "$APPDIR/usr/share/patchopsiii/dxvk_manager.py"
          install -Dm644 main.py "$APPDIR/usr/share/patchopsiii/main.py"
          install -Dm644 t7_patch.py "$APPDIR/usr/share/patchopsiii/t7_patch.py"
          install -Dm644 utils.py "$APPDIR/usr/share/patchopsiii/utils.py"
      - name: Install Python dependencies into AppDir
        env:
          PIP_DISABLE_PIP_VERSION_CHECK: '1'
          PYTHONNOUSERSITE: '1'
        run: |
          set -euo pipefail
          APPDIR="$PWD/AppDir"
          PYTHON_BIN="$APPDIR/opt/python3.11/bin/python3.11"
          if [ ! -x "$PYTHON_BIN" ]; then
            echo "Bundled Python runtime not found at $PYTHON_BIN" >&2
            exit 1
          fi
          "$PYTHON_BIN" -m pip install --upgrade pip
          "$PYTHON_BIN" -m pip install --no-compile --no-warn-script-location \
            --target "$APPDIR/opt/python3.11/lib/python3.11/site-packages" \
            -r requirements.txt
      - name: Build AppImage
        run: |
          set -euo pipefail
          APPDIR="$PWD/AppDir"
          export PATH="$PWD/tools:$PATH"
          tools/appimagetool-x86_64.AppImage "$APPDIR" "$LINUX_APPIMAGE"
      - name: Collect AppImage artifact
        run: |
          set -euo pipefail
          APPIMAGE_PATH=$(ls -1 PatchOpsIII*.AppImage | head -n1)
          if [ -z "$APPIMAGE_PATH" ]; then
            echo "No AppImage produced" >&2
            exit 1
          fi
          mv "$APPIMAGE_PATH" "$LINUX_DIST_DIR/$LINUX_APPIMAGE"
      - name: Ensure AppImage is executable
        run: |
          target="$LINUX_DIST_DIR/$LINUX_APPIMAGE"
          if [ ! -f "$target" ]; then
            echo "$target was not produced" >&2
            exit 1
          fi
          chmod +x "$target"
      - name: Install cosign (optional)
        if: ${{ env.COSIGN_PRIVATE_KEY != '' }}
        uses: sigstore/cosign-installer@v3.4.0
      - name: Sign AppImage with cosign
        if: ${{ env.COSIGN_PRIVATE_KEY != '' }}
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: |
          target="$LINUX_DIST_DIR/$LINUX_APPIMAGE"
          if [ ! -f "$target" ]; then
            echo "$target was not produced" >&2
            exit 1
          fi
          printf "%s" "$COSIGN_PRIVATE_KEY" > cosign.key
          cosign sign-blob --yes --key cosign.key --output-signature "$target.sig" --output-certificate "$target.pem" "$target"
          rm -f cosign.key
      - name: Compute AppImage hash
        id: compute_hash
        run: |
          target="$LINUX_DIST_DIR/$LINUX_APPIMAGE"
          if [ ! -f "$target" ]; then
            echo "$target was not produced" >&2
            exit 1
          fi
          hash=$(sha256sum "$target" | cut -d ' ' -f1)
          printf "%s\n" "$hash" > "$LINUX_DIST_DIR/hash.log"
          echo "SHA256: $hash"
          vt_url="https://www.virustotal.com/gui/file/$hash"
          echo "LINUX_VT_URL=$vt_url" >> "$GITHUB_ENV"
          printf "hash=%s\n" "$hash" >> "$GITHUB_OUTPUT"
          printf "vt_url=%s\n" "$vt_url" >> "$GITHUB_OUTPUT"
      - name: Determine VirusTotal CLI release
        id: vt_release
        if: ${{ env.VT_API_KEY != '' }}
        run: |
          set -euo pipefail
          python <<'PY'
          import json
          import os
          import urllib.request

          url = 'https://api.github.com/repos/VirusTotal/vt-cli/releases/latest'
          with urllib.request.urlopen(url) as response:
              data = json.load(response)
          tag = data.get('tag_name')
          try:
              asset_url = next(asset['browser_download_url'] for asset in data['assets'] if asset['name'] == 'Linux64.zip')
          except StopIteration:
              raise SystemExit('Linux64.zip asset not found in VirusTotal CLI release metadata')
          if not tag:
              raise SystemExit('Release tag missing from VirusTotal CLI metadata')
          with open(os.environ['GITHUB_OUTPUT'], 'a', encoding='utf-8') as fh:
              fh.write(f'tag={tag}\n')
              fh.write(f'url={asset_url}\n')
          PY
      - name: Cache VirusTotal CLI
        if: ${{ env.VT_API_KEY != '' }}
        id: cache-vt
        uses: actions/cache@v4
        with:
          path: |
            vt
            ${{ env.VT_CLI_ARCHIVE }}
          key: vt-${{ runner.os }}-${{ steps.vt_release.outputs.tag }}
      - name: Download VirusTotal CLI
        if: ${{ env.VT_API_KEY != '' && steps.cache-vt.outputs.cache-hit != 'true' }}
        run: |
          set -euo pipefail
          curl -sSL "${{ steps.vt_release.outputs.url }}" -o "$VT_CLI_ARCHIVE"
          unzip -q -o "$VT_CLI_ARCHIVE"
      - name: Ensure VirusTotal CLI executable
        if: ${{ env.VT_API_KEY != '' }}
        run: |
          if [ -f vt ]; then
            chmod +x vt
          else
            echo 'VirusTotal CLI binary not found' >&2
            exit 1
          fi
      - name: VirusTotal scan (optional)
        if: ${{ env.VT_API_KEY != '' }}
        env:
          VT_API_KEY: ${{ env.VT_API_KEY }}
        run: |
          ./vt scan file "$LINUX_DIST_DIR/$LINUX_APPIMAGE" --wait --apikey "$VT_API_KEY"
      - name: Upload AppImage artifact
        uses: actions/upload-artifact@v4
        with:
          name: PatchOpsIII-linux
          path: |
            ${{ env.LINUX_DIST_DIR }}/${{ env.LINUX_APPIMAGE }}
            ${{ env.LINUX_DIST_DIR }}/hash.log
            ${{ env.LINUX_DIST_DIR }}/${{ env.LINUX_APPIMAGE }}.sig
            ${{ env.LINUX_DIST_DIR }}/${{ env.LINUX_APPIMAGE }}.pem
          if-no-files-found: ignore
