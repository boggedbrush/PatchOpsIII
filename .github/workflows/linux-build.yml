name: Linux Build

on:
  push:
    branches:
      - Testing
      - testing
  pull_request:
    branches:
      - Testing
      - testing
  workflow_dispatch:
  workflow_call:
    inputs:
      ref:
        description: Git ref to build
        required: false
        type: string
        default: ''
    outputs:
      hash:
        description: SHA256 hash of the AppImage
        value: ${{ jobs.build-linux.outputs.hash }}
      vt_url:
        description: VirusTotal URL for the AppImage
        value: ${{ jobs.build-linux.outputs.vt_url }}
      artifact_name:
        description: Name of the produced artifact
        value: ${{ jobs.build-linux.outputs.artifact_name }}

permissions:
  contents: read
  id-token: write

jobs:
  build-linux:
    name: Build Linux AppImage
    runs-on: ubuntu-latest
    outputs:
      hash: ${{ steps.compute_hash.outputs.hash }}
      vt_url: ${{ steps.compute_hash.outputs.vt_url }}
      artifact_name: PatchOpsIII-linux
    defaults:
      run:
        shell: bash
        working-directory: .
    env:
      LINUX_DIST_DIR: dist/linux
      LINUX_APPIMAGE: PatchOpsIII.AppImage
      LINUX_BINARY: PatchOpsIII
      VT_CLI_ARCHIVE: vt-cli.zip
      COSIGN_PRIVATE_KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}
      COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
      VT_API_KEY: ${{ secrets.VT_API_KEY }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref != '' && inputs.ref || github.ref }}
      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y clang
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: requirements.txt
      - name: Install dependencies
        run: |
          python -m pip install -r requirements.txt
          python -m pip install --upgrade nuitka pillow
      - name: Cache Nuitka build artifacts
        id: cache-nuitka
        uses: actions/cache@v4
        with:
          path: |
            PatchOpsIII.build
            PatchOpsIII.dist
            PatchOpsIII.onefile-build
            .nuitka-cache
          key: nuitka-${{ runner.os }}-${{ github.sha }}
      - name: Prepare build directories
        run: |
          rm -rf dist build
          if [ '${{ steps.cache-nuitka.outputs.cache-hit }}' != 'true' ]; then
            rm -rf PatchOpsIII.build PatchOpsIII.dist PatchOpsIII.onefile-build .nuitka-cache
          fi
          rm -f PatchOpsIII.spec
          rm -f PatchOpsIII.png
          mkdir -p "$LINUX_DIST_DIR"
      - name: Generate AppImage icon
        run: |
          python <<'PY'
          from pathlib import Path
          from PIL import Image

          ico_path = Path('PatchOpsIII.ico')
          png_path = Path('PatchOpsIII.png')
          image = Image.open(ico_path)
          frame_index = 0
          if getattr(image, 'n_frames', 1) > 1:
              candidates = []
              for idx in range(image.n_frames):
                  image.seek(idx)
                  candidates.append((idx, image.size[0] * image.size[1]))
              frame_index = max(candidates, key=lambda item: item[1])[0]
              image.seek(frame_index)
          image.convert('RGBA').save(png_path, format='PNG')
          PY
      - name: Build AppImage with Nuitka
        run: |
          python -m nuitka \
            --onefile \
            --onefile-no-compression \
            --clang \
            --lto=yes \
            --assume-yes-for-downloads \
            --enable-plugins=pyside6 \
            --include-qt-plugins=sensible,platforms \
            --nofollow-import-to=PySide6.QtWebEngineCore \
            --nofollow-import-to=PySide6.QtWebEngineWidgets \
            --nofollow-import-to=PySide6.QtWebEngine \
            --nofollow-import-to=PySide6.QtWebEngineQuick \
            --nofollow-import-to=PySide6.QtMultimedia \
            --nofollow-import-to=PySide6.QtMultimediaWidgets \
            --nofollow-import-to=PySide6.QtOpenGLWidgets \
            --include-package=vdf \
            --include-package=requests \
            --include-data-file=presets.json=presets.json \
            --include-data-file=PatchOpsIII.ico=PatchOpsIII.ico \
            --linux-icon=PatchOpsIII.png \
            --output-dir="$LINUX_DIST_DIR" \
            --output-filename="$LINUX_APPIMAGE" \
            main.py
      - name: Prepare binary
        run: |
          target="$LINUX_DIST_DIR/$LINUX_APPIMAGE"
          binary="$LINUX_DIST_DIR/$LINUX_BINARY"
          if [ ! -f "$target" ]; then
            echo "$target was not produced" >&2
            exit 1
          fi
          mv "$target" "$binary"
          chmod +x "$binary"
      - name: Create AppDir
        run: |
          APPDIR="$LINUX_DIST_DIR/AppDir"
          mkdir -p "$APPDIR/usr/bin" "$APPDIR/usr/share/applications" "$APPDIR/usr/share/icons/hicolor/256x256/apps"
          cp "$LINUX_DIST_DIR/$LINUX_BINARY" "$APPDIR/usr/bin/PatchOpsIII"
          cat > "$APPDIR/usr/share/applications/PatchOpsIII.desktop" <<'DESK'
          [Desktop Entry]
          Type=Application
          Name=PatchOpsIII
          Exec=PatchOpsIII
          Icon=PatchOpsIII
          Categories=Utility;
          DESK
          cp PatchOpsIII.png "$APPDIR/usr/share/icons/hicolor/256x256/apps/PatchOpsIII.png"
          # Make sure AppRun exists if linuxdeployqt needs it (optional)
          cat > "$APPDIR/AppRun" <<'SH'
          #!/bin/sh
          HERE="$(dirname "$(readlink -f "$0")")"
          exec "$HERE/usr/bin/PatchOpsIII" "$@"
          SH
          chmod +x "$APPDIR/AppRun"
      - name: Download and verify linuxdeployqt
        run: |
          set -euo pipefail
          LD="$LINUX_DIST_DIR"
          cd "$LD"
          # Preferred: set URL to the correct release asset. If you don't know the exact asset name,
          # use the Releases API or host a known-good copy in your repo/releases.
          LDD_URL="https://github.com/probonopd/linuxdeployqt/releases/download/continuous/linuxdeployqt-continuous-x86_64.AppImage"
          # download and fail on http errors
          curl -fsSL -o linuxdeployqt.AppImage "$LDD_URL" || { echo "Failed to download linuxdeployqt from $LDD_URL"; ls -l; exit 1; }
          chmod +x linuxdeployqt.AppImage
          # quick sanity checks: must be an ELF/AppImage (not an HTML error)
          file linuxdeployqt.AppImage | tee linuxdeployqt.file.txt
          if ! file linuxdeployqt.AppImage | grep -qi -e 'ELF' -e 'AppImage' ; then
            echo "linuxdeployqt download appears invalid. Showing first 16 bytes for debugging:"
            head -c 256 linuxdeployqt.AppImage | sed -n '1,6p' || true
            exit 1
          fi
      - name: Build AppImage with linuxdeployqt
        run: |
          set -euo pipefail
          APPDIR="$LINUX_DIST_DIR/AppDir"
          cd "$LINUX_DIST_DIR"
          ./linuxdeployqt.AppImage "$APPDIR/usr/share/applications/PatchOpsIII.desktop" -appimage || { echo "linuxdeployqt failed"; ls -al; exit 1; }
          gen=$(ls ./*.AppImage 2>/dev/null | grep -i PatchOpsIII | head -n1 || true)
          if [ -z "$gen" ]; then
            echo "linuxdeployqt did not produce an AppImage" >&2
            ls -al
            exit 1
          fi
          mv "$gen" "$LINUX_DIST_DIR/$LINUX_APPIMAGE"
          chmod +x "$LINUX_DIST_DIR/$LINUX_APPIMAGE"
      - name: Debug linuxdeployqt download (optional)
        if: failure()
        run: |
          echo "linuxdeployqt.AppImage file info:"
          ls -l "$LINUX_DIST_DIR/linuxdeployqt.AppImage" || true
          head -n 20 "$LINUX_DIST_DIR/linuxdeployqt.AppImage" || true
          curl -I "https://github.com/probonopd/linuxdeployqt/releases/download/continuous/linuxdeployqt-continuous-x86_64.AppImage" || true
      - name: Smoke-test AppImage
        run: |
          target="$LINUX_DIST_DIR/$LINUX_APPIMAGE"
          "$target" --appimage-extract >/dev/null 2>&1 || { echo "AppImage extract failed" >&2; exit 1; }
          rm -rf squashfs-root || true
      - name: Install cosign (optional)
        if: ${{ env.COSIGN_PRIVATE_KEY != '' }}
        uses: sigstore/cosign-installer@v3.4.0
      - name: Sign AppImage with cosign
        if: ${{ env.COSIGN_PRIVATE_KEY != '' }}
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: |
          target="$LINUX_DIST_DIR/$LINUX_APPIMAGE"
          if [ ! -f "$target" ]; then
            echo "$target was not produced" >&2
            exit 1
          fi
          printf "%s" "$COSIGN_PRIVATE_KEY" > cosign.key
          cosign sign-blob --yes --key cosign.key --output-signature "$target.sig" --output-certificate "$target.pem" "$target"
          rm -f cosign.key
      - name: Compute AppImage hash
        id: compute_hash
        run: |
          target="$LINUX_DIST_DIR/$LINUX_APPIMAGE"
          if [ ! -f "$target" ]; then
            echo "$target was not produced" >&2
            exit 1
          fi
          hash=$(sha256sum "$target" | cut -d ' ' -f1)
          printf "%s\n" "$hash" > "$LINUX_DIST_DIR/hash.log"
          echo "SHA256: $hash"
          vt_url="https://www.virustotal.com/gui/file/$hash"
          echo "LINUX_VT_URL=$vt_url" >> "$GITHUB_ENV"
          printf "hash=%s\n" "$hash" >> "$GITHUB_OUTPUT"
          printf "vt_url=%s\n" "$vt_url" >> "$GITHUB_OUTPUT"
      - name: Determine VirusTotal CLI release
        id: vt_release
        if: ${{ env.VT_API_KEY != '' }}
        run: |
          set -euo pipefail
          python <<'PY'
          import json
          import os
          import urllib.request

          url = 'https://api.github.com/repos/VirusTotal/vt-cli/releases/latest'
          with urllib.request.urlopen(url) as response:
              data = json.load(response)
          tag = data.get('tag_name')
          try:
              asset_url = next(asset['browser_download_url'] for asset in data['assets'] if asset['name'] == 'Linux64.zip')
          except StopIteration:
              raise SystemExit('Linux64.zip asset not found in VirusTotal CLI release metadata')
          if not tag:
              raise SystemExit('Release tag missing from VirusTotal CLI metadata')
          with open(os.environ['GITHUB_OUTPUT'], 'a', encoding='utf-8') as fh:
              fh.write(f'tag={tag}\n')
              fh.write(f'url={asset_url}\n')
          PY
      - name: Cache VirusTotal CLI
        if: ${{ env.VT_API_KEY != '' }}
        id: cache-vt
        uses: actions/cache@v4
        with:
          path: |
            vt
            ${{ env.VT_CLI_ARCHIVE }}
          key: vt-${{ runner.os }}-${{ steps.vt_release.outputs.tag }}
      - name: Download VirusTotal CLI
        if: ${{ env.VT_API_KEY != '' && steps.cache-vt.outputs.cache-hit != 'true' }}
        run: |
          set -euo pipefail
          curl -sSL "${{ steps.vt_release.outputs.url }}" -o "$VT_CLI_ARCHIVE"
          unzip -q -o "$VT_CLI_ARCHIVE"
      - name: Ensure VirusTotal CLI executable
        if: ${{ env.VT_API_KEY != '' }}
        run: |
          if [ -f vt ]; then
            chmod +x vt
          else
            echo 'VirusTotal CLI binary not found' >&2
            exit 1
          fi
      - name: VirusTotal scan (optional)
        if: ${{ env.VT_API_KEY != '' }}
        env:
          VT_API_KEY: ${{ env.VT_API_KEY }}
        run: |
          ./vt scan file "$LINUX_DIST_DIR/$LINUX_APPIMAGE" --wait --apikey "$VT_API_KEY"
      - name: Upload AppImage artifact
        uses: actions/upload-artifact@v4
        with:
          name: PatchOpsIII-linux
          path: |
            ${{ env.LINUX_DIST_DIR }}/${{ env.LINUX_APPIMAGE }}
            ${{ env.LINUX_DIST_DIR }}/hash.log
            ${{ env.LINUX_DIST_DIR }}/${{ env.LINUX_APPIMAGE }}.sig
            ${{ env.LINUX_DIST_DIR }}/${{ env.LINUX_APPIMAGE }}.pem
          if-no-files-found: ignore
